\subsection*{A4O3.5}
Programming languages using type inferrence allows the programmer to be more free when programming, not having to worry about types all the time. This could in general make writing code easier, as it makes the procedure of writing code less complicated, and might especially be well suited for people who are new to programming, or at least to a specific programming language. Type inferrence makes the learning curve less steep. \par
It is also convenient when not quite knowing what type a function will output, maybe because there are multiple possible types of putput. This let the programmer implement one single function or procedure for something that might have needed several functions if the type wasn't inferred. In "Programming Language Design and Implementation" section 8.1 we are given a conditional as an example. Here, different branches of the conditional could give different types for the answer. Here, type inferrence is convenient, as we can still have one combined conditional, even though the resulting types vary. \par
Furthermore, in the specific case of \texttt{qsort} it is practical that the compiler can itself infer what type of dictionary it needs for sorting a list, so that the programmer need not worry about this, as it would probably not enhance the programmers understanding of the program, but would only slow the programmer down.\par

However, type inferrence can also make the code more difficult to understand, and less clear, as the programmer is not forced to have an overview of the types of the program. This often helps a progremmer think his or her programs through, and thus causes the programmer to make less errors. On top of this, it also means more work for the compiler, as it needs to perform all this type inferrence instead of letting the programmer do it.\par
And even though type inferrence makes the learning curve of a programming language less steep, it sometimes also prevents the programmer from truly writing good programs. Take for example C - when you first start learning it it might seem very difficult and hard to understand intuitively, but when you get good at it it might actually give you more freedom than some other programming languages.\par

A combination where we get some advantages of type inferrence, without getting the disadvantages, could be an example where the compiler infers the type whenever it is possible. Whenever types are ambiguous the compiler could produce an error, forcing the programmer to make the code unambiguous. Using this combination, we both get to be lazy, but never lets the compiler choose for us.\par
Another combination could be \textit{soft typing}, as mentioned on page 154 in the notes. Soft typing never rejects programs as faulty, but instead uses dynamic type checking in the places where type inferrence is unamboguous. This can, according to the notes, be used as feedback for the programmer, and is often used for optimisation of dynamically typed languages.
